<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>RSI Pump/Dump Signal – Binance USDT Futures</title>
  <!-- Tailwind CSS CDN for modern styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Custom styles for Inter font and general body layout */
    body {
      font-family: 'Inter', sans-serif;
      /* Dark theme styling with a slightly softer background */
      @apply bg-gray-950 text-gray-200 flex flex-col items-center justify-start min-h-screen p-4 sm:p-6 lg:p-8;
    }
    h1, h2 {
      @apply text-white; /* White text for headings */
    }
    #signal {
      @apply text-5xl font-extrabold mt-6 mb-4; /* Larger, bolder text for the main signal */
    }
    #currentSymbolInfo {
      @apply text-gray-400 text-xl; /* Slightly larger, gray text for debug info */
    }
    table {
      /* Increased max-width for more space, subtle border, and shadow */
      @apply w-full max-w-7xl border border-gray-700 rounded-xl shadow-2xl overflow-hidden mt-10;
    }
    th, td {
      @apply border border-gray-800 px-4 py-3 text-left; /* Borders and padding for table cells */
    }
    th {
      /* Styling for table headers, making them clickable, with a subtle gradient */
      @apply bg-gray-800 text-white cursor-pointer hover:bg-gray-700 transition duration-200 ease-in-out
             bg-gradient-to-b from-gray-800 to-gray-700;
    }
    th .sort-indicator {
      @apply inline-block ml-2 text-gray-400 transition-transform duration-200 ease-in-out;
    }
    th.sort-asc .sort-indicator {
      transform: rotate(0deg); /* Up arrow default */
    }
    th.sort-desc .sort-indicator {
      transform: rotate(180deg); /* Down arrow */
    }
    tbody tr:nth-child(even) {
      @apply bg-gray-800; /* Alternate row background for readability */
    }
    tbody tr:nth-child(odd) {
      @apply bg-gray-850; /* Slightly darker alternate row background */
    }
    tbody tr:hover {
      /* Stronger hover effect for table rows with subtle lift and shadow */
      @apply bg-gray-700 transform scale-[1.005] shadow-lg;
      transition: all 0.1s ease-out; /* Smooth transition for the effect */
    }
    /* Specific text colors for different signal types - more vibrant */
    .pump-signal {
      @apply text-green-400 font-bold; /* Brighter green */
    }
    .dump-signal {
      @apply text-red-400 font-bold; /* Brighter red */
    }
    .neutral-signal {
      @apply text-blue-300; /* A distinct blue for neutral */
    }
    .no-data-signal, .error-signal {
      @apply text-gray-500; /* Consistent gray for data issues */
    }

    /* Styling for the main content containers */
    .main-card {
      @apply bg-gray-800 p-6 sm:p-8 rounded-xl shadow-lg border border-gray-700;
    }
    .dropdown-container {
      @apply relative w-full max-w-md mx-auto;
    }
    select {
      @apply w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200 ease-in-out;
    }
  </style>
</head>
<body>
  <div class="w-full flex flex-col items-center">
    <h1 class="text-5xl font-extrabold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-blue-500">
      Binance RSI Signal
    </h1>
    <h2 class="text-3xl mb-8 text-gray-300">15m Timeframe – Live USDT Perpetual Pairs</h2>

    <!-- Dropdown for selecting a single symbol for live updates -->
    <div class="dropdown-container mb-10">
      <select id="symbolSelect">
        <option disabled selected>Loading symbols...</option>
      </select>
    </div>

    <!-- Live signal display for the selected symbol -->
    <div class="main-card text-center mb-10 w-full max-w-lg">
      <p class="text-gray-400 text-lg mb-2">Selected Pair Signal:</p>
      <div id="signal" class="text-green-400">Waiting for selection...</div>
      <div id="currentSymbolInfo" class="text-gray-400"></div>
    </div>

    <h2 class="text-3xl mt-8 mb-6 text-white text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-500">
      All USDT Perpetual Pairs (Live Overview)
    </h2>
    <p class="text-sm text-red-400 mb-4 text-center max-w-2xl">
      <strong class="font-bold">Warning:</strong> Tracking all symbols live can be resource-intensive and may lead to performance issues or Binance API rate limits.
    </p>
    <!-- Table to display live data for tracked symbols, with sortable headers -->
    <table id="allSymbolsTable">
      <thead>
        <tr>
          <th data-sort="symbol">Symbol <span class="sort-indicator"></span></th>
          <th data-sort="rsiStart">RSI Start <span class="sort-indicator"></span></th>
          <th data-sort="rsiEnd">RSI End <span class="sort-indicator"></span></th>
          <th data-sort="rsiDiff">RSI Diff <span class="sort-indicator"></span></th>
          <th data-sort="signal">Signal <span class="sort-indicator"></span></th>
        </tr>
      </thead>
      <tbody id="allSymbolsTableBody">
        <!-- Rows will be dynamically inserted here by JavaScript -->
        <tr><td colspan="5" class="text-center text-gray-500 py-4">Loading all available pairs... This may take a moment.</td></tr>
      </tbody>
    </table>
  </div>

  <script>
    // Configuration constants for Binance API and RSI calculation
    const interval = '15m'; // Timeframe for klines
    const limit = 100; // Number of historical klines to fetch for RSI calculation
    const rsiPeriod = 14; // Period for RSI calculation
    // const MAX_TRACKED_SYMBOLS_FOR_TABLE = 20; // Removed limit to track all symbols

    let closes = []; // Stores close prices for the currently selected symbol (for live updates in the top section)
    let singleSymbolWebSocket; // WebSocket object for the currently selected symbol (from dropdown)

    // Data structures for the live table overview
    const symbolClosesMap = new Map(); // Map<symbol, number[]> stores historical closes for each tracked symbol
    const liveTableDataMap = new Map(); // Map<symbol, object> stores the latest RSI signal data for each tracked symbol
    const liveTableWebSockets = new Map(); // Map<symbol, WebSocket> stores WebSocket instances for live table updates

    let currentSortColumn = 'symbol'; // Default sorting column for the table
    let currentSortDirection = 'asc'; // Default sorting direction for the table
    let tableUpdateAnimationFrameId = null; // Used to debounce table rendering

    // Reconnection variables for single symbol WebSocket
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 10;
    const BASE_RECONNECT_DELAY_MS = 1000; // 1 second
    const MAX_RECONNECT_DELAY_MS = 60000; // Cap delay at 60 seconds

    // --- RSI Calculation and Signal Functions ---

    /**
     * Calculates the recent RSI difference, including pump/dump strength and direction.
     * This function helps quantify the recent movement of the RSI.
     * @param {number[]} rsi - Array of RSI values.
     * @param {number} lookback - Number of recent RSI values to consider for pump/dump analysis.
     * @returns {object|null} An object containing recentHigh, recentLow, pumpStrength, dumpStrength, direction, strength, or null if not enough data.
     */
    const getRecentRSIDiff = (rsi, lookback = 14) => {
      if (rsi.length < lookback) return null;

      const recentRSI = rsi.slice(-lookback); // Get the most recent RSI values
      let recentHigh = -Infinity;
      let recentLow = Infinity;

      // Find the highest and lowest RSI values within the lookback period
      for (const value of recentRSI) {
        if (!isNaN(value)) { // Ensure the value is a number
          if (value > recentHigh) recentHigh = value;
          if (value < recentLow) recentLow = value;
        }
      }

      const pumpStrength = recentHigh - recentLow; // Difference between recent high and low
      const dumpStrength = Math.abs(recentLow - recentHigh); // Absolute difference (same as pumpStrength)

      const startRSI = recentRSI[0]; // RSI value at the start of the lookback period
      const endRSI = recentRSI[recentRSI.length - 1]; // Current (most recent) RSI value
      // Determine the direction of movement (pump, dump, or neutral)
      const direction = endRSI > startRSI ? 'pump' : endRSI < startRSI ? 'dump' : 'neutral';
      const strength = Math.abs(endRSI - startRSI); // Absolute change from start to end

      return {
        recentHigh,
        recentLow,
        pumpStrength,
        dumpStrength,
        direction,
        strength
      };
    };

    /**
     * Determines a trading signal based on the calculated RSI pump/dump characteristics.
     * This function categorizes the RSI movement into different "zones" (MAX, BALANCE, LOWEST).
     * @param {object} s - An object containing rsi14 (array of RSI values).
     * @returns {string} The determined signal (e.g., 'MAX ZONE PUMP', 'NO STRONG SIGNAL').
     */
    const getSignal = (s) => {
      // Get pump/dump data from the RSI values
      const pumpDump = s.rsi14 ? getRecentRSIDiff(s.rsi14, 14) : null;
      if (!pumpDump) return 'NO DATA'; // Return 'NO DATA' if pumpDump is null

      const direction = pumpDump.direction;
      const pump = pumpDump.pumpStrength;
      const dump = pumpDump.dumpStrength;

      // Helper functions to check if a value is within a range or above a threshold
      const inRange = (val, min, max) => val !== undefined && val >= min && val <= max;
      const isAbove30 = (val) => val !== undefined && val >= 30;

      const pumpAbove30 = isAbove30(pump);
      const dumpAbove30 = isAbove30(dump);

      const pumpInRange_21_26 = inRange(pump, 21, 26);
      const dumpInRange_21_26 = inRange(dump, 21, 26);

      const pumpInRange_1_10 = inRange(pump, 1, 10);
      const dumpInRange_1_10 = inRange(dump, 1, 10);

      // Apply signal logic based on direction and strength zones
      if (direction === 'pump' && pumpAbove30) return 'MAX ZONE PUMP';
      if (direction === 'dump' && dumpAbove30) return 'MAX ZONE DUMP';
      if (pumpInRange_21_26 && direction === 'pump') return 'BALANCE ZONE PUMP';
      if (dumpInRange_21_26 && direction === 'dump') return 'BALANCE ZONE DUMP';
      if (pumpInRange_1_10 && direction === 'pump') return 'LOWEST ZONE PUMP';
      if (dumpInRange_1_10 && direction === 'dump') return 'LOWEST ZONE DUMP';

      return 'NO STRONG SIGNAL'; // Default signal if no specific conditions are met
    };

    /**
     * Computes the Relative Strength Index (RSI) for a given data set of closing prices.
     * @param {number[]} data - Array of closing prices.
     * @param {number} period - The period for RSI calculation (e.g., 14 for 14-period RSI).
     * @returns {number[]} An array of RSI values, filtering out initial NaN values.
     */
    const computeRSI = (data, period = 14) => {
      const rsi = [];
      let gains = 0;
      let losses = 0;

      // Initial calculation for the first 'period' values to establish initial average gain/loss
      if (data.length < period + 1) return []; // Not enough data for initial RSI calculation

      for (let i = 1; i < period + 1; i++) {
        const change = data[i] - data[i - 1];
        if (change > 0) gains += change;
        else losses -= change;
      }

      let avgGain = gains / period;
      let avgLoss = losses / period;
      // Handle division by zero for avgLoss to prevent Infinity/NaN RSI
      rsi[period] = avgLoss === 0 ? 100 : 100 - (100 / (1 + avgGain / avgLoss));

      // Subsequent calculations using smoothing formula
      for (let i = period + 1; i < data.length; i++) {
        const change = data[i] - data[i - 1];
        const gain = Math.max(change, 0); // Only positive changes contribute to gain
        const loss = Math.max(-change, 0); // Only negative changes (absolute) contribute to loss

        // Smoothed average gain/loss
        avgGain = (avgGain * (period - 1) + gain) / period;
        avgLoss = (avgLoss * (period - 1) + loss) / period;

        // Calculate RSI for the current period
        rsi[i] = avgLoss === 0 ? 100 : 100 - (100 / (1 + avgGain / avgLoss));
      }

      // Filter out initial undefined/NaN values that occur before enough data points are collected
      return rsi.filter(val => !isNaN(val));
    };

    // --- Live Signal Display for Selected Symbol (Top Section) ---

    /**
     * Updates the main signal display and current symbol info for the selected symbol.
     * This function is called frequently by the WebSocket to show real-time updates.
     * @param {string} signal - The calculated signal string.
     * @param {number[]} rsiValues - The recent RSI values used for the signal.
     */
    const updateLiveSignalDisplay = (signal, rsiValues) => {
      const signalEl = document.getElementById('signal');
      const currentSymbolInfoEl = document.getElementById('currentSymbolInfo');

      signalEl.textContent = signal; // Update the signal text

      // Apply appropriate color class based on the signal type
      let signalColorClass = 'neutral-signal';
      if (signal.includes('PUMP')) {
        signalColorClass = 'pump-signal';
      } else if (signal.includes('DUMP')) {
        signalColorClass = 'dump-signal';
      } else if (signal.includes('NO DATA') || signal.includes('ERROR') || signal.includes('WS ERROR') || signal.includes('FETCH ERROR') || signal.includes('RECONNECTING') || signal.includes('DISCONNECTED') || signal.includes('NOT ENOUGH DATA')) {
        signalColorClass = 'no-data-signal';
      }
      // Update the class list, preserving base styling
      signalEl.className = `text-5xl font-extrabold mt-6 mb-4 ${signalColorClass}`;

      // Calculate and display RSI start, end, and difference for debugging/info
      const start = rsiValues.length > 0 ? rsiValues[0] : NaN;
      const end = rsiValues.length > 0 ? rsiValues[rsiValues.length - 1] : NaN;
      const diff = !isNaN(start) && !isNaN(end) ? (end - start).toFixed(2) : 'N/A';

      currentSymbolInfoEl.innerText = `RSI Start: ${isNaN(start) ? 'N/A' : start.toFixed(2)}, End: ${isNaN(end) ? 'N/A' : end.toFixed(2)}, Diff: ${diff}`;
    };

    /**
     * Runs the signal calculation for the current 'closes' data (of the selected symbol)
     * and updates the live display.
     */
    const runLiveSignalForSingleSymbol = () => {
      // Ensure enough data points are available for RSI calculation
      if (closes.length < rsiPeriod + 1) {
        updateLiveSignalDisplay('NOT ENOUGH DATA', []);
        return;
      }
      const rsi = computeRSI(closes, rsiPeriod);
      // Ensure enough RSI values are available for getRecentRSIDiff's lookback (14)
      const rsiForSignal = rsi.slice(-30); // Use a larger slice to ensure enough data for lookback
      const signal = getSignal({ rsi14: rsiForSignal });
      updateLiveSignalDisplay(signal, rsiForSignal);
    };

    /**
     * Connects to the Binance WebSocket for the given symbol to receive live kline updates.
     * Manages closing previous connections and handling errors/reconnections.
     * This is for the single symbol selected in the dropdown.
     * @param {string} symbol - The trading pair symbol (e.g., 'BTCUSDT').
     */
    const connectSingleSymbolWebSocket = (symbol) => {
      if (singleSymbolWebSocket) {
        singleSymbolWebSocket.close(); // Close any existing WebSocket connection
        console.log(`Closed previous single symbol WebSocket for ${singleSymbolWebSocket.url}`);
      }
      reconnectAttempts = 0; // Reset attempts *before* trying to connect for a new symbol
      // Construct WebSocket URL for Binance Futures kline stream
      singleSymbolWebSocket = new WebSocket(`wss://fstream.binance.com/ws/${symbol.toLowerCase()}@kline_${interval}`);
      console.log(`Attempting to connect single symbol WebSocket for ${symbol}...`);

      singleSymbolWebSocket.onopen = () => {
        console.log(`Single symbol WebSocket opened successfully for ${symbol}`);
        updateLiveSignalDisplay('CONNECTED', []); // Indicate successful connection
      };

      singleSymbolWebSocket.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        const k = msg.k; // kline data
        if (k.x) { // k.x is true when the candle (bar) is closed
          const close = parseFloat(k.c); // Get the closing price
          closes.push(close); // Add to our historical closes array
          if (closes.length > limit) closes.shift(); // Keep the array size within 'limit'
          runLiveSignalForSingleSymbol(); // Recalculate and update the live signal
        }
      };

      singleSymbolWebSocket.onerror = (error) => {
        console.error(`Single symbol WebSocket error for ${symbol}:`, error);
        // Error handling is primarily done in onclose for consistent UI updates
      };

      singleSymbolWebSocket.onclose = (event) => {
        console.log(`Single symbol WebSocket closed for ${symbol}:`, event.code, event.reason);
        // Attempt to reconnect only if the close was not clean (e.g., unexpected disconnection)
        if (!event.wasClean && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
          reconnectAttempts++;
          const delay = Math.min(BASE_RECONNECT_DELAY_MS * Math.pow(2, reconnectAttempts - 1), MAX_RECONNECT_DELAY_MS);
          console.log(`Single symbol WebSocket not closed cleanly, attempting to reconnect ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay / 1000} seconds...`);
          updateLiveSignalDisplay(`RECONNECTING... (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`, []);
          setTimeout(() => connectSingleSymbolWebSocket(symbol), delay);
        } else if (!event.wasClean) {
          updateLiveSignalDisplay('MAX RECONNECT ATTEMPTS REACHED', []);
          console.error('Max reconnection attempts reached for single symbol. Please refresh the page manually.');
        } else {
          updateLiveSignalDisplay('DISCONNECTED', []); // For clean disconnections
        }
      };
    };

    /**
     * Fetches initial historical klines data for a given symbol.
     * This is used to populate the 'closes' array before WebSocket updates begin.
     * This is for the single symbol selected in the dropdown.
     * @param {string} symbol - The trading pair symbol.
     */
    const fetchInitialKlinesForSingleSymbol = async (symbol) => {
      const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol.toUpperCase()}&interval=${interval}&limit=${limit}`;
      try {
        const res = await fetch(url);
        if (!res.ok) {
          throw new Error(`HTTP error! status: ${res.status}`);
        }
        const data = await res.json();
        closes = data.map(k => parseFloat(k[4])); // Extract closing prices from the klines data
        runLiveSignalForSingleSymbol(); // Run signal calculation with this initial historical data
      } catch (error) {
        console.error(`Failed to fetch initial klines for ${symbol}:`, error);
        updateLiveSignalDisplay('FETCH ERROR', []); // Display an error if fetching fails
      }
    };

    // --- All Symbols Table (Live Overview) and Sorting Logic ---

    /**
     * Schedules the table rendering to happen on the next animation frame.
     * This debounces updates to prevent excessive re-renders and flickering.
     */
    const scheduleTableRender = () => {
      if (!tableUpdateAnimationFrameId) {
        tableUpdateAnimationFrameId = requestAnimationFrame(() => {
          renderAllSymbolsTable(Array.from(liveTableDataMap.values()));
          tableUpdateAnimationFrameId = null; // Reset the ID after rendering
        });
      }
    };

    /**
     * Renders or re-renders the table with all symbols' live data.
     * @param {Array<object>} data - The array of symbol data objects to render.
     */
    const renderAllSymbolsTable = (data) => {
      const tbody = document.getElementById('allSymbolsTableBody');
      tbody.innerHTML = ''; // Clear existing rows before rendering new ones

      // Sort the data before rendering
      data.sort((a, b) => {
        let valA = a[currentSortColumn];
        let valB = b[currentSortColumn];

        // Handle numeric conversions for proper sorting of numbers
        if (currentSortColumn.includes('rsi') || currentSortColumn === 'rsiDiff') {
          valA = parseFloat(valA);
          valB = parseFloat(valB);
          // Handle null/NaN values during numeric comparison
          if (isNaN(valA) && isNaN(valB)) return 0;
          if (isNaN(valA)) return currentSortDirection === 'asc' ? 1 : -1;
          if (isNaN(valB)) return currentSortDirection === 'asc' ? -1 : 1;
        } else if (typeof valA === 'string') {
          // Case-insensitive string comparison for symbol and signal
          valA = valA.toLowerCase();
          valB = valB.toLowerCase();
        }

        if (valA < valB) return currentSortDirection === 'asc' ? -1 : 1;
        if (valA > valB) return currentSortDirection === 'asc' ? 1 : -1;
        return 0; // Values are equal
      });

      // Update sort indicators in headers
      document.querySelectorAll('#allSymbolsTable th').forEach(header => {
        const indicator = header.querySelector('.sort-indicator');
        if (indicator) {
          if (header.dataset.sort === currentSortColumn) {
            header.classList.add(currentSortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
            header.classList.remove(currentSortDirection === 'asc' ? 'sort-desc' : 'sort-asc');
            indicator.textContent = currentSortDirection === 'asc' ? '▲' : '▼';
          } else {
            header.classList.remove('sort-asc', 'sort-desc');
            indicator.textContent = ''; // Clear icon if not the sorted column
          }
        }
      });


      if (data.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" class="text-center text-gray-500 py-4">No live data available for display.</td></tr>';
        return;
      }

      data.forEach(item => {
        const row = document.createElement('tr');
        // Determine the CSS class for the signal text based on its content
        const signalClass = item.signal.includes('PUMP') ? 'pump-signal' :
                           item.signal.includes('DUMP') ? 'dump-signal' :
                           item.signal.includes('NO DATA') || item.signal.includes('ERROR') || item.signal.includes('NOT ENOUGH DATA') ? 'no-data-signal' :
                           'neutral-signal';

        // Populate the row with symbol data, formatting numbers to 2 decimal places or N/A
        row.innerHTML = `
          <td>${item.symbol}</td>
          <td>${item.rsiStart !== null && !isNaN(item.rsiStart) ? item.rsiStart.toFixed(2) : 'N/A'}</td>
          <td>${item.rsiEnd !== null && !isNaN(item.rsiEnd) ? item.rsiEnd.toFixed(2) : 'N/A'}</td>
          <td>${item.rsiDiff !== null && !isNaN(item.rsiDiff) ? item.rsiDiff.toFixed(2) : 'N/A'}</td>
          <td class="${signalClass}">${item.signal}</td>
        `;
        tbody.appendChild(row); // Add the new row to the table body
      });
    };

    /**
     * Sorts the `liveTableDataMap` values based on the specified column and direction,
     * then re-renders the table.
     * @param {string} column - The data key (column name) to sort by (e.g., 'symbol', 'rsiStart').
     */
    const sortTable = (column) => {
      // Toggle sort direction if the same column is clicked again
      if (currentSortColumn === column) {
        currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        currentSortColumn = column;
        currentSortDirection = 'asc'; // Default to ascending for a new column
      }
      // Trigger a re-render which will apply the new sort order
      scheduleTableRender();
    };

    // Add event listeners to table headers for sorting functionality
    document.querySelectorAll('#allSymbolsTable th').forEach(header => {
      header.addEventListener('click', () => {
        const column = header.dataset.sort; // Get the column name from data-sort attribute
        if (column) {
          sortTable(column);
        }
      });
    });

    /**
     * Initializes parallel WebSocket streams for a limited number of symbols
     * to populate the live overview table.
     * @param {string[]} usdtPairs - An array of all available USDT perpetual symbols.
     */
    const initializeLiveTableTracking = async (usdtPairs) => {
      // Clear previous live table data and WebSockets if any
      symbolClosesMap.clear();
      liveTableDataMap.clear();
      liveTableWebSockets.forEach(ws => ws.close()); // Close existing WS connections
      liveTableWebSockets.clear();

      // IMPORTANT CHANGE: Track ALL symbols instead of slicing
      const trackedSymbols = usdtPairs; // Now tracking all symbols

      // Display loading message for the table initially
      document.getElementById('allSymbolsTableBody').innerHTML = '<tr><td colspan="5" class="text-center text-gray-500 py-4">Loading all available pairs... This may take a moment.</td></tr>';

      for (const symbol of trackedSymbols) {
        symbolClosesMap.set(symbol, []); // Initialize closes array for each symbol

        // Fetch initial klines for each tracked symbol
        const klinesUrl = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol.toUpperCase()}&interval=${interval}&limit=${limit}`;
        try {
          const res = await fetch(klinesUrl);
          if (!res.ok) {
            console.warn(`Could not fetch initial klines for ${symbol}: HTTP status ${res.status}.`);
            liveTableDataMap.set(symbol, {
              symbol, rsiStart: null, rsiEnd: null, rsiDiff: null, signal: 'FETCH ERROR'
            });
            scheduleTableRender(); // Schedule render even on error to update table
            continue; // Skip to the next symbol if initial fetch fails
          }
          const data = await res.json();
          const initialCloses = data.map(k => parseFloat(k[4]));
          symbolClosesMap.set(symbol, initialCloses);

          // Compute initial RSI and signal for the table
          if (initialCloses.length >= rsiPeriod + 1) {
            const rsi = computeRSI(initialCloses, rsiPeriod);
            const rsiSlice = rsi.slice(-30);
            const signal = getSignal({ rsi14: rsiSlice });
            liveTableDataMap.set(symbol, {
              symbol,
              rsiStart: rsiSlice.length > 0 ? rsiSlice[0] : null,
              rsiEnd: rsiSlice.length > 0 ? rsiSlice[rsiSlice.length - 1] : null,
              rsiDiff: (rsiSlice.length > 0 && rsiSlice[0] !== null && rsiSlice[rsiSlice.length - 1] !== null) ? (rsiSlice[rsiSlice.length - 1] - rsiSlice[0]) : null,
              signal,
            });
          } else {
            liveTableDataMap.set(symbol, {
              symbol, rsiStart: null, rsiEnd: null, rsiDiff: null, signal: 'NOT ENOUGH DATA'
            });
          }
        } catch (error) {
          console.error(`Error fetching initial klines for ${symbol}:`, error);
          liveTableDataMap.set(symbol, {
            symbol, rsiStart: null, rsiEnd: null, rsiDiff: null, signal: 'ERROR'
          });
        }
        scheduleTableRender(); // Schedule initial table render after each symbol's data is processed

        // Establish WebSocket connection for live updates
        const streamName = `${symbol.toLowerCase()}@kline_${interval}`;
        const ws = new WebSocket(`wss://fstream.binance.com/ws/${streamName}`);
        liveTableWebSockets.set(symbol, ws); // Store WebSocket instance

        ws.onmessage = (event) => {
          const msg = JSON.parse(event.data);
          const k = msg.k;

          if (k.x) { // Closed candle
            const close = parseFloat(k.c);
            const closesForSymbol = symbolClosesMap.get(symbol);
            if (closesForSymbol) {
              closesForSymbol.push(close);
              if (closesForSymbol.length > limit) closesForSymbol.shift();

              if (closesForSymbol.length >= rsiPeriod + 1) {
                const rsi = computeRSI(closesForSymbol);
                const rsiSlice = rsi.slice(-30);
                const signal = getSignal({ rsi14: rsiSlice });

                liveTableDataMap.set(symbol, {
                  symbol,
                  rsiStart: rsiSlice.length > 0 ? rsiSlice[0] : null,
                  rsiEnd: rsiSlice.length > 0 ? rsiSlice[rsiSlice.length - 1] : null,
                  rsiDiff: (rsiSlice.length > 0 && rsiSlice[0] !== null && rsiSlice[rsiSlice.length - 1] !== null) ? (rsiSlice[rsiSlice.length - 1] - rsiSlice[0]) : null,
                  signal,
                });
              } else {
                 liveTableDataMap.set(symbol, {
                  symbol, rsiStart: null, rsiEnd: null, rsiDiff: null, signal: 'NOT ENOUGH DATA'
                });
              }
            }
            scheduleTableRender(); // Schedule a table re-render
          }
        };

        ws.onerror = (error) => {
          console.error(`Live table WebSocket error for ${symbol}:`, error);
          liveTableDataMap.set(symbol, {
            symbol, rsiStart: null, rsiEnd: null, rsiDiff: null, signal: 'WS ERROR'
          });
          scheduleTableRender();
        };

        ws.onclose = (event) => {
          console.log(`Live table WebSocket closed for ${symbol}:`, event.code, event.reason);
          // Simple reconnection attempt for live table symbols (can be improved with backoff if needed)
          if (!event.wasClean) {
            console.log(`Attempting to re-establish live table WebSocket for ${symbol}...`);
            // To prevent infinite loops, a simple delay is used here. For production, consider full exponential backoff.
            setTimeout(() => {
                const newWs = new WebSocket(`wss://fstream.binance.com/ws/${symbol.toLowerCase()}@kline_${interval}`);
                liveTableWebSockets.set(symbol, newWs); // Update the map with the new WS instance
                // Re-attach onmessage, onerror, onclose handlers here for the newWs
                newWs.onmessage = ws.onmessage;
                newWs.onerror = ws.onerror;
                newWs.onclose = ws.onclose;
            }, 5000); // Try reconnecting after 5 seconds
          }
        };
      }
    };

    /**
     * Loads all USDT perpetual symbols from Binance, populates the dropdown,
     * and then initializes the live table tracking.
     */
    const loadSymbolsAndInitializeApp = async () => {
      const symbolSelect = document.getElementById('symbolSelect');
      symbolSelect.innerHTML = `<option disabled selected>Loading symbols...</option>`; // Initial loading state

      const exchangeInfoUrl = `https://fapi.binance.com/fapi/v1/exchangeInfo`;
      try {
        const res = await fetch(exchangeInfoUrl);
        if (!res.ok) {
          throw new Error(`HTTP error! status: ${res.status}`);
        }
        const data = await res.json();

        // Filter for USDT perpetual trading pairs that are currently active
        const usdtPairs = data.symbols
          .filter(s => s.quoteAsset === 'USDT' && s.contractType === 'PERPETUAL' && s.status === 'TRADING')
          .map(s => s.symbol);

        // Populate the symbol selection dropdown
        symbolSelect.innerHTML = `<option disabled selected>Select a symbol</option>`;
        usdtPairs.forEach(sym => {
          const opt = document.createElement('option');
          opt.value = sym;
          opt.textContent = sym;
          symbolSelect.appendChild(opt);
        });

        // Initialize live table tracking for a subset of symbols
        await initializeLiveTableTracking(usdtPairs);

      } catch (error) {
        console.error('Failed to load symbols or initial data:', error);
        symbolSelect.innerHTML = `<option disabled selected>Error loading symbols</option>`;
        document.getElementById('allSymbolsTableBody').innerHTML = '<tr><td colspan="5" class="text-center text-red-500 py-4">Failed to load symbols for table.</td></tr>';
      }
    };

    // Event listener for when a symbol is selected from the dropdown
    document.getElementById('symbolSelect').onchange = (event) => {
      const selectedSymbol = event.target.value;
      document.getElementById('signal').textContent = 'Loading live data...';
      document.getElementById('currentSymbolInfo').textContent = '';
      fetchInitialKlinesForSingleSymbol(selectedSymbol);
      connectSingleSymbolWebSocket(selectedSymbol);
    };

    // Initial load of symbols and data for the table when the page loads
    loadSymbolsAndInitializeApp();
  </script>
</body>
</html>
