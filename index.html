<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>RSI Pump/Dump Signal – Binance USDT Futures</title>
  <!-- Tailwind CSS CDN for modern styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Custom styles for Inter font and general body layout */
    body {
      font-family: 'Inter', sans-serif;
      /* Dark theme styling with a slightly softer background */
      @apply bg-gray-950 text-gray-200 flex flex-col items-center justify-start min-h-screen p-4 sm:p-6 lg:p-8;
    }
    h1, h2 {
      @apply text-white; /* White text for headings */
    }
    #signal {
      @apply text-5xl font-extrabold mt-6 mb-4; /* Larger, bolder text for the main signal */
    }
    #currentSymbolInfo {
      @apply text-gray-400 text-xl; /* Slightly larger, gray text for debug info */
    }
    table {
      /* Increased max-width for more space, subtle border, and shadow */
      @apply w-full max-w-7xl border border-gray-700 rounded-xl shadow-2xl overflow-hidden mt-10;
    }
    th, td {
      @apply border border-gray-800 px-4 py-3 text-left; /* Borders and padding for table cells */
    }
    th {
      /* Styling for table headers, making them clickable, with a subtle gradient */
      @apply bg-gray-800 text-white cursor-pointer hover:bg-gray-700 transition duration-200 ease-in-out
             bg-gradient-to-b from-gray-800 to-gray-700;
    }
    th .sort-indicator {
      @apply inline-block ml-2 text-gray-400 transition-transform duration-200 ease-in-out;
    }
    th.sort-asc .sort-indicator {
      transform: rotate(0deg); /* Up arrow default */
    }
    th.sort-desc .sort-indicator {
      transform: rotate(180deg); /* Down arrow */
    }
    tbody tr:nth-child(even) {
      @apply bg-gray-800; /* Alternate row background for readability */
    }
    tbody tr:nth-child(odd) {
      @apply bg-gray-850; /* Slightly darker alternate row background */
    }
    tbody tr:hover {
      /* Stronger hover effect for table rows with subtle lift and shadow */
      @apply bg-gray-700 transform scale-[1.005] shadow-lg;
      transition: all 0.1s ease-out; /* Smooth transition for the effect */
    }
    /* Specific text colors and subtle backgrounds for different signal types */
    .pump-signal-cell {
      @apply text-green-300 font-bold bg-green-800/40; /* More noticeable green background */
    }
    .dump-signal-cell {
      @apply text-red-300 font-bold bg-red-800/40; /* More noticeable red background */
    }
    .neutral-signal-cell {
      @apply text-blue-300 bg-blue-800/40; /* More noticeable blue background */
    }
    .no-data-signal-cell, .error-signal-cell {
      @apply text-gray-400 bg-gray-700/40; /* Slightly lighter text, more noticeable gray background */
    }

    /* Styling for the main content containers */
    .main-card {
      @apply bg-gray-800 p-6 sm:p-8 rounded-xl shadow-lg border border-gray-700;
    }
    .dropdown-container {
      @apply relative w-full max-w-md mx-auto;
    }
    select {
      @apply w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200 ease-in-out;
    }
    /* Signal summary card styling */
    .signal-summary-card > div {
      @apply rounded-lg p-3;
    }
  </style>
</head>
<body>
  <div class="w-full flex flex-col items-center">
    <h1 class="text-5xl font-extrabold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-blue-500">
      Binance RSI Signal
    </h1>
    <h2 class="text-3xl mb-8 text-gray-300">15m Timeframe – Live USDT Perpetual Pairs</h2>

    <!-- Dropdown for selecting a single symbol for live updates -->
    <div class="dropdown-container mb-10">
      <select id="symbolSelect">
        <option disabled selected>Loading symbols...</option>
      </select>
    </div>

    <!-- Live signal display for the selected symbol -->
    <div class="main-card text-center mb-10 w-full max-w-lg">
      <p class="text-gray-400 text-lg mb-2">Selected Pair Signal:</p>
      <div id="signal" class="text-green-400">Waiting for selection...</div>
      <div id="currentSymbolInfo" class="text-gray-400"></div>
    </div>

    <h2 class="text-3xl mt-8 mb-6 text-white text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-500">
      All USDT Perpetual Pairs (Live Overview)
    </h2>
    <p class="text-sm text-yellow-400 mb-4 text-center max-w-2xl">
      This table updates every 15 seconds. Data is fetched in batches to comply with API rate limits.
    </p>

    <!-- Signal Summary Counts -->
    <div class="signal-summary-card bg-gray-800 p-6 rounded-xl shadow-lg mb-10 w-full max-w-7xl grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-4 border border-gray-700">
        <div class="text-center bg-gray-700">
            <p class="text-gray-400 text-sm">Total Symbols</p>
            <p id="totalSymbolsCount" class="text-white text-2xl font-bold">0</p>
        </div>
        <div class="text-center bg-green-900/30 border border-green-700">
            <p class="text-green-300 text-sm">PUMP Signals</p>
            <p id="pumpSignalsCount" class="text-green-300 text-2xl font-bold">0</p>
        </div>
        <div class="text-center bg-red-900/30 border border-red-700">
            <p class="text-red-300 text-sm">DUMP Signals</p>
            <p id="dumpSignalsCount" class="text-red-300 text-2xl font-bold">0</p>
        </div>
        <div class="text-center bg-blue-900/30 border border-blue-700">
            <p class="text-blue-300 text-sm">Neutral Signals</p>
            <p id="neutralSignalsCount" class="text-blue-300 text-2xl font-bold">0</p>
        </div>
        <div class="text-center bg-gray-900/30 border border-gray-700">
            <p class="text-gray-400 text-sm">No Signal / Error</p>
            <p id="noSignalErrorCount" class="text-gray-400 text-2xl font-bold">0</p>
        </div>
    </div>

    <!-- Table to display live data for tracked symbols, with sortable headers -->
    <table id="allSymbolsTable">
      <thead>
        <tr>
          <th data-sort="symbol">Symbol <span class="sort-indicator"></span></th>
          <th data-sort="rsiStart">RSI Start <span class="sort-indicator"></span></th>
          <th data-sort="rsiEnd">RSI End <span class="sort-indicator"></span></th>
          <th data-sort="rsiDiff">RSI Diff <span class="sort-indicator"></span></th>
          <th data-sort="signal">Signal <span class="sort-indicator"></span></th>
        </tr>
      </thead>
      <tbody id="allSymbolsTableBody">
        <!-- Rows will be dynamically inserted here by JavaScript -->
        <tr><td colspan="5" class="text-center text-gray-500 py-4">Loading all available pairs... This may take a moment.</td></tr>
      </tbody>
    </table>
  </div>

  <script>
    // Configuration constants for Binance API and RSI calculation
    const interval = '15m'; // Timeframe for klines
    const limit = 100; // Number of historical klines to fetch for RSI calculation
    const rsiPeriod = 14; // Period for RSI calculation

    // Global variables for all symbols and table data
    let allUsdtPairs = []; // Stores all available USDT perpetual pairs
    const liveTableDataMap = new Map(); // Map<symbol, object> stores the latest RSI signal data for each tracked symbol

    // Table sorting state
    let currentSortColumn = 'symbol';
    let currentSortDirection = 'asc';
    let tableUpdateAnimationFrameId = null; // Used to debounce table rendering

    // Batching and update interval for the table
    const UPDATE_INTERVAL_MS = 15000; // Refresh table data every 15 seconds
    const SYMBOLS_PER_BATCH = 10; // Number of symbols to fetch concurrently in one batch
    const BATCH_PROCESSING_DELAY_MS = 500; // Delay between processing each batch

    // Single symbol WebSocket (for dropdown)
    let closes = []; // Stores close prices for the currently selected symbol (for live updates in the top section)
    let singleSymbolWebSocket;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 10;
    const BASE_RECONNECT_DELAY_MS = 1000; // 1 second
    const MAX_RECONNECT_DELAY_MS = 60000; // Cap delay at 60 seconds

    // --- RSI Calculation and Signal Functions ---

    /**
     * Calculates the recent RSI difference, including pump/dump strength and direction.
     * This function helps quantify the recent movement of the RSI.
     * @param {number[]} rsi - Array of RSI values.
     * @param {number} lookback - Number of recent RSI values to consider for pump/dump analysis.
     * @returns {object|null} An object containing recentHigh, recentLow, pumpStrength, dumpStrength, direction, strength, or null if not enough data.
     */
    const getRecentRSIDiff = (rsi, lookback = 14) => {
      if (rsi.length < lookback) return null;

      const recentRSI = rsi.slice(-lookback); // Get the most recent RSI values
      let recentHigh = -Infinity;
      let recentLow = Infinity;

      // Find the highest and lowest RSI values within the lookback period
      for (const value of recentRSI) {
        if (!isNaN(value)) { // Ensure the value is a number
          if (value > recentHigh) recentHigh = value;
          if (value < recentLow) recentLow = value;
        }
      }

      const pumpStrength = recentHigh - recentLow; // Difference between recent high and low
      const dumpStrength = Math.abs(recentLow - recentHigh); // Absolute difference (same as pumpStrength)

      const startRSI = recentRSI[0]; // RSI value at the start of the lookback period
      const endRSI = recentRSI[recentRSI.length - 1]; // Current (most recent) RSI value
      // Determine the direction of movement (pump, dump, or neutral)
      const direction = endRSI > startRSI ? 'pump' : endRSI < startRSI ? 'dump' : 'neutral';
      const strength = Math.abs(endRSI - startRSI); // Absolute change from start to end

      return {
        recentHigh,
        recentLow,
        pumpStrength,
        dumpStrength,
        direction,
        strength
      };
    };

    /**
     * Determines a trading signal based on the calculated RSI pump/dump characteristics.
     * This function categorizes the RSI movement into different "zones" (MAX, BALANCE, LOWEST).
     * @param {object} s - An object containing rsi14 (array of RSI values).
     * @returns {string} The determined signal (e.g., 'MAX ZONE PUMP', 'NO STRONG SIGNAL').
     */
    const getSignal = (s) => {
      // Get pump/dump data from the RSI values
      const pumpDump = s.rsi14 ? getRecentRSIDiff(s.rsi14, 14) : null;
      if (!pumpDump) return 'NO DATA'; // Return 'NO DATA' if pumpDump is null

      const direction = pumpDump.direction;
      const pump = pumpDump.pumpStrength;
      const dump = pumpDump.dumpStrength;

      // Helper functions to check if a value is within a range or above a threshold
      const inRange = (val, min, max) => val !== undefined && val >= min && val <= max;
      const isAbove30 = (val) => val !== undefined && val >= 30;

      const pumpAbove30 = isAbove30(pump);
      const dumpAbove30 = isAbove30(dump);

      const pumpInRange_21_26 = inRange(pump, 21, 26);
      const dumpInRange_21_26 = inRange(dump, 21, 26);

      const pumpInRange_1_10 = inRange(pump, 1, 10);
      const dumpInRange_1_10 = inRange(dump, 1, 10);

      // Apply signal logic based on direction and strength zones
      if (direction === 'pump' && pumpAbove30) return 'MAX ZONE PUMP';
      if (direction === 'dump' && dumpAbove30) return 'MAX ZONE DUMP';
      if (pumpInRange_21_26 && direction === 'pump') return 'BALANCE ZONE PUMP';
      if (dumpInRange_21_26 && direction === 'dump') return 'BALANCE ZONE DUMP';
      if (pumpInRange_1_10 && direction === 'pump') return 'LOWEST ZONE PUMP';
      if (dumpInRange_1_10 && direction === 'dump') return 'LOWEST ZONE DUMP';

      return 'NO STRONG SIGNAL'; // Default signal if no specific conditions are met
    };

    /**
     * Computes the Relative Strength Index (RSI) for a given data set of closing prices.
     * @param {number[]} data - Array of closing prices.
     * @param {number} period - The period for RSI calculation (e.g., 14 for 14-period RSI).
     * @returns {number[]} An array of RSI values, filtering out initial NaN values.
     */
    const computeRSI = (data, period = 14) => {
      const rsi = [];
      let gains = 0;
      let losses = 0;

      // Initial calculation for the first 'period' values to establish initial average gain/loss
      if (data.length < period + 1) return []; // Not enough data for initial RSI calculation

      for (let i = 1; i < period + 1; i++) {
        const change = data[i] - data[i - 1];
        if (change > 0) gains += change;
        else losses -= change;
      }

      let avgGain = gains / period;
      let avgLoss = losses / period;
      // Handle division by zero for avgLoss to prevent Infinity/NaN RSI
      rsi[period] = avgLoss === 0 ? 100 : 100 - (100 / (1 + avgGain / avgLoss));

      // Subsequent calculations using smoothing formula
      for (let i = period + 1; i < data.length; i++) {
        const change = data[i] - data[i - 1];
        const gain = Math.max(change, 0); // Only positive changes contribute to gain
        const loss = Math.max(-change, 0); // Only negative changes (absolute) contribute to loss

        // Smoothed average gain/loss
        avgGain = (avgGain * (period - 1) + gain) / period;
        avgLoss = (avgLoss * (period - 1) + loss) / period;

        // Calculate RSI for the current period
        rsi[i] = avgLoss === 0 ? 100 : 100 - (100 / (1 + avgGain / avgLoss));
      }

      // Filter out initial undefined/NaN values that occur before enough data points are collected
      return rsi.filter(val => !isNaN(val));
    };

    // --- Live Signal Display for Selected Symbol (Top Section) ---

    /**
     * Updates the main signal display and current symbol info for the selected symbol.
     * This function is called frequently by the WebSocket to show real-time updates.
     * @param {string} signal - The calculated signal string.
     * @param {number[]} rsiValues - The recent RSI values used for the signal.
     */
    const updateLiveSignalDisplay = (signal, rsiValues) => {
      const signalEl = document.getElementById('signal');
      const currentSymbolInfoEl = document.getElementById('currentSymbolInfo');

      signalEl.textContent = signal; // Update the signal text

      // Apply appropriate color class based on the signal type
      let signalColorClass = 'neutral-signal';
      if (signal.includes('PUMP')) {
        signalColorClass = 'pump-signal';
      } else if (signal.includes('DUMP')) {
        signalColorClass = 'dump-signal';
      } else if (signal.includes('NO DATA') || signal.includes('ERROR') || signal.includes('WS ERROR') || signal.includes('FETCH ERROR') || signal.includes('RECONNECTING') || signal.includes('DISCONNECTED') || signal.includes('NOT ENOUGH DATA')) {
        signalColorClass = 'no-data-signal';
      }
      // Update the class list, preserving base styling
      signalEl.className = `text-5xl font-extrabold mt-6 mb-4 ${signalColorClass}`;

      // Calculate and display RSI start, end, and difference for debugging/info
      const start = rsiValues.length > 0 ? rsiValues[0] : NaN;
      const end = rsiValues.length > 0 ? rsiValues[rsiValues.length - 1] : NaN;
      const diff = !isNaN(start) && !isNaN(end) ? (end - start).toFixed(2) : 'N/A';

      currentSymbolInfoEl.innerText = `RSI Start: ${isNaN(start) ? 'N/A' : start.toFixed(2)}, End: ${isNaN(end) ? 'N/A' : end.toFixed(2)}, Diff: ${diff}`;
    };

    /**
     * Runs the signal calculation for the current 'closes' data (of the selected symbol)
     * and updates the live display.
     */
    const runLiveSignalForSingleSymbol = () => {
      // Ensure enough data points are available for RSI calculation
      if (closes.length < rsiPeriod + 1) {
        updateLiveSignalDisplay('NOT ENOUGH DATA', []);
        return;
      }
      const rsi = computeRSI(closes, rsiPeriod);
      // Ensure enough RSI values are available for getRecentRSIDiff's lookback (14)
      const rsiForSignal = rsi.slice(-30); // Use a larger slice to ensure enough data for lookback
      const signal = getSignal({ rsi14: rsiForSignal });
      updateLiveSignalDisplay(signal, rsiForSignal);
    };

    /**
     * Connects to the Binance WebSocket for the given symbol to receive live kline updates.
     * Manages closing previous connections and handling errors/reconnections.
     * This is for the single symbol selected in the dropdown.
     * @param {string} symbol - The trading pair symbol (e.g., 'BTCUSDT').
     */
    const connectSingleSymbolWebSocket = (symbol) => {
      if (singleSymbolWebSocket) {
        singleSymbolWebSocket.close(); // Close any existing WebSocket connection
        console.log(`Closed previous single symbol WebSocket for ${singleSymbolWebSocket.url}`);
      }
      reconnectAttempts = 0; // Reset attempts *before* trying to connect for a new symbol
      // Construct WebSocket URL for Binance Futures kline stream
      singleSymbolWebSocket = new WebSocket(`wss://fstream.binance.com/ws/${symbol.toLowerCase()}@kline_${interval}`);
      console.log(`Attempting to connect single symbol WebSocket for ${symbol}...`);

      singleSymbolWebSocket.onopen = () => {
        console.log(`Single symbol WebSocket opened successfully for ${symbol}`);
        updateLiveSignalDisplay('CONNECTED', []); // Indicate successful connection
      };

      singleSymbolWebSocket.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        const k = msg.k; // kline data
        if (k.x) { // k.x is true when the candle (bar) is closed
          const close = parseFloat(k.c); // Get the closing price
          closes.push(close); // Add to our historical closes array
          if (closes.length > limit) closes.shift(); // Keep the array size within 'limit'
          runLiveSignalForSingleSymbol(); // Recalculate and update the live signal
        }
      };

      singleSymbolWebSocket.onerror = (error) => {
        console.error(`Single symbol WebSocket error for ${symbol}:`, error);
        // Error handling is primarily done in onclose for consistent UI updates
      };

      singleSymbolWebSocket.onclose = (event) => {
        console.log(`Single symbol WebSocket closed for ${symbol}:`, event.code, event.reason);
        // Attempt to reconnect only if the close was not clean (e.g., unexpected disconnection)
        if (!event.wasClean && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
          reconnectAttempts++;
          const delay = Math.min(BASE_RECONNECT_DELAY_MS * Math.pow(2, reconnectAttempts - 1), MAX_RECONNECT_DELAY_MS);
          console.log(`Single symbol WebSocket not closed cleanly, attempting to reconnect ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay / 1000} seconds...`);
          updateLiveSignalDisplay(`RECONNECTING... (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`, []);
          setTimeout(() => connectSingleSymbolWebSocket(symbol), delay);
        } else if (!event.wasClean) {
          updateLiveSignalDisplay('MAX RECONNECT ATTEMPTS REACHED', []);
          console.error('Max reconnection attempts reached for single symbol. Please refresh the page manually.');
        } else {
          updateLiveSignalDisplay('DISCONNECTED', []); // For clean disconnections
        }
      };
    };

    /**
     * Fetches initial historical klines data for a given symbol.
     * This is used to populate the 'closes' array before WebSocket updates begin.
     * This is for the single symbol selected in the dropdown.
     * @param {string} symbol - The trading pair symbol.
     */
    const fetchInitialKlinesForSingleSymbol = async (symbol) => {
      const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol.toUpperCase()}&interval=${interval}&limit=${limit}`;
      try {
        const res = await fetch(url);
        if (!res.ok) {
          throw new Error(`HTTP error! status: ${res.status}`);
        }
        const data = await res.json();
        closes = data.map(k => parseFloat(k[4])); // Extract closing prices from the klines data
        runLiveSignalForSingleSymbol(); // Run signal calculation with this initial historical data
      } catch (error) {
        console.error(`Failed to fetch initial klines for ${symbol}:`, error);
        updateLiveSignalDisplay('FETCH ERROR', []); // Display an error if fetching fails
      }
    };

    // --- All Symbols Table (Live Overview) and Sorting Logic ---

    /**
     * Schedules the table rendering to happen on the next animation frame.
     * This debounces updates to prevent excessive re-renders and flickering.
     */
    const scheduleTableRender = () => {
      if (!tableUpdateAnimationFrameId) {
        tableUpdateAnimationFrameId = requestAnimationFrame(() => {
          renderAllSymbolsTable(Array.from(liveTableDataMap.values()));
          tableUpdateAnimationFrameId = null; // Reset the ID after rendering
        });
      }
    };

    /**
     * Renders or re-renders the table with all symbols' live data.
     * @param {Array<object>} data - The array of symbol data objects to render.
     */
    const renderAllSymbolsTable = (data) => {
      const tbody = document.getElementById('allSymbolsTableBody');
      tbody.innerHTML = ''; // Clear existing rows before rendering new ones

      // Sort the data before rendering
      data.sort((a, b) => {
        let valA = a[currentSortColumn];
        let valB = b[currentSortColumn];

        // Handle numeric conversions for proper sorting of numbers
        if (currentSortColumn.includes('rsi') || currentSortColumn === 'rsiDiff') {
          valA = parseFloat(valA);
          valB = parseFloat(valB);
          // Handle null/NaN values during numeric comparison
          if (isNaN(valA) && isNaN(valB)) return 0;
          if (isNaN(valA)) return currentSortDirection === 'asc' ? 1 : -1;
          if (isNaN(valB)) return currentSortDirection === 'asc' ? -1 : 1;
        } else if (typeof valA === 'string') {
          // Case-insensitive string comparison for symbol and signal
          valA = valA.toLowerCase();
          valB = valB.toLowerCase();
        }

        if (valA < valB) return currentSortDirection === 'asc' ? -1 : 1;
        if (valA > valB) return currentSortDirection === 'asc' ? 1 : -1;
        return 0; // Values are equal
      });

      // Update sort indicators in headers
      document.querySelectorAll('#allSymbolsTable th').forEach(header => {
        const indicator = header.querySelector('.sort-indicator');
        if (indicator) {
          if (header.dataset.sort === currentSortColumn) {
            header.classList.add(currentSortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
            header.classList.remove(currentSortDirection === 'asc' ? 'sort-desc' : 'sort-asc');
            indicator.textContent = currentSortDirection === 'asc' ? '▲' : '▼';
          } else {
            header.classList.remove('sort-asc', 'sort-desc');
            indicator.textContent = ''; // Clear icon if not the sorted column
          }
        }
      });

      // Calculate and update signal counts
      const counts = {
          total: data.length,
          pump: 0,
          dump: 0,
          neutral: 0, // For 'NO STRONG SIGNAL'
          noDataError: 0 // For 'NO DATA', 'FETCH ERROR', 'ERROR', 'NOT ENOUGH DATA'
      };

      data.forEach(item => {
          if (item.signal.includes('PUMP')) {
              counts.pump++;
          } else if (item.signal.includes('DUMP')) {
              counts.dump++;
          } else if (item.signal.includes('NO STRONG SIGNAL')) {
              counts.neutral++;
          } else if (item.signal.includes('NO DATA') || item.signal.includes('ERROR') || item.signal.includes('NOT ENOUGH DATA') || item.signal.includes('FETCH ERROR')) {
              counts.noDataError++;
          }
      });

      document.getElementById('totalSymbolsCount').textContent = counts.total;
      document.getElementById('pumpSignalsCount').textContent = counts.pump;
      document.getElementById('dumpSignalsCount').textContent = counts.dump;
      document.getElementById('neutralSignalsCount').textContent = counts.neutral;
      document.getElementById('noSignalErrorCount').textContent = counts.noDataError;


      if (data.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" class="text-center text-gray-500 py-4">No live data available for display.</td></tr>';
        return;
      }

      data.forEach(item => {
        const row = document.createElement('tr');
        // Determine the CSS class for the signal text and cell background based on its content
        let signalClass = '';

        if (item.signal.includes('PUMP')) {
          signalClass = 'pump-signal-cell';
        } else if (item.signal.includes('DUMP')) {
          signalClass = 'dump-signal-cell';
        } else if (item.signal.includes('NO STRONG SIGNAL')) {
          signalClass = 'neutral-signal-cell';
        } else { // Includes 'NO DATA', 'ERROR', 'NOT ENOUGH DATA', 'FETCH ERROR'
          signalClass = 'no-data-signal-cell';
        }

        // Populate the row with symbol data, formatting numbers to 2 decimal places or N/A
        row.innerHTML = `
          <td>${item.symbol}</td>
          <td>${item.rsiStart !== null && !isNaN(item.rsiStart) ? item.rsiStart.toFixed(2) : 'N/A'}</td>
          <td>${item.rsiEnd !== null && !isNaN(item.rsiEnd) ? item.rsiEnd.toFixed(2) : 'N/A'}</td>
          <td>${item.rsiDiff !== null && !isNaN(item.rsiDiff) ? item.rsiDiff.toFixed(2) : 'N/A'}</td>
          <td class="${signalClass}">${item.signal}</td>
        `;
        tbody.appendChild(row); // Add the new row to the table body
      });
    };

    /**
     * Sorts the `liveTableDataMap` values based on the specified column and direction,
     * then re-renders the table.
     * @param {string} column - The data key (column name) to sort by (e.g., 'symbol', 'rsiStart').
     */
    const sortTable = (column) => {
      // Toggle sort direction if the same column is clicked again
      if (currentSortColumn === column) {
        currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        currentSortColumn = column;
        currentSortDirection = 'asc'; // Default to ascending for a new column
      }
      // Trigger a re-render which will apply the new sort order
      scheduleTableRender();
    };

    // Add event listeners to table headers for sorting functionality
    document.querySelectorAll('#allSymbolsTable th').forEach(header => {
      header.addEventListener('click', () => {
        const column = header.dataset.sort; // Get the column name from data-sort attribute
        if (column) {
          sortTable(column);
        }
      });
    });

    /**
     * Fetches klines for a single symbol. Used by batch fetching.
     * @param {string} symbol - The trading pair symbol.
     * @returns {Promise<object|null>} Processed symbol data or null on error.
     */
    const fetchKlinesAndProcessRSI = async (symbol) => {
        const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol.toUpperCase()}&interval=${interval}&limit=${limit}`;
        try {
            const res = await fetch(url);
            if (!res.ok) {
                console.warn(`Could not fetch klines for ${symbol}: HTTP status ${res.status}.`);
                return { symbol, rsiStart: null, rsiEnd: null, rsiDiff: null, signal: 'FETCH ERROR' };
            }
            const data = await res.json();
            const symbolCloses = data.map(k => parseFloat(k[4]));

            if (symbolCloses.length >= rsiPeriod + 1) {
                const rsi = computeRSI(symbolCloses, rsiPeriod);
                const rsiSlice = rsi.slice(-30);
                const signal = getSignal({ rsi14: rsiSlice });

                return {
                    symbol,
                    rsiStart: rsiSlice.length > 0 ? rsiSlice[0] : null,
                    rsiEnd: rsiSlice.length > 0 ? rsiSlice[rsiSlice.length - 1] : null,
                    rsiDiff: (rsiSlice.length > 0 && rsiSlice[0] !== null && rsiSlice[rsiSlice.length - 1] !== null) ? (rsiSlice[rsiSlice.length - 1] - rsiSlice[0]) : null,
                    signal,
                };
            } else {
                return { symbol, rsiStart: null, rsiEnd: null, rsiDiff: null, signal: 'NOT ENOUGH DATA' };
            }
        } catch (error) {
            console.error(`Error fetching klines or processing RSI for ${symbol}:`, error);
            return { symbol, rsiStart: null, rsiEnd: null, rsiDiff: null, signal: 'ERROR' };
        }
    };

    /**
     * Refreshes all symbols' data for the table using batch fetching.
     * This is called periodically by setInterval.
     */
    const refreshAllSymbolsTableData = async () => {
        if (allUsdtPairs.length === 0) {
            console.warn("No USDT pairs loaded yet for table refresh.");
            return;
        }

        document.getElementById('allSymbolsTableBody').innerHTML = '<tr><td colspan="5" class="text-center text-gray-500 py-4">Updating all pairs...</td></tr>';

        for (let i = 0; i < allUsdtPairs.length; i += SYMBOLS_PER_BATCH) {
            const batchSymbols = allUsdtPairs.slice(i, i + SYMBOLS_PER_BATCH);
            const batchPromises = batchSymbols.map(symbol => fetchKlinesAndProcessRSI(symbol));

            const results = await Promise.all(batchPromises); // Fetch batch concurrently

            results.forEach(item => {
                if (item) { // Ensure item is not null from fetchKlinesAndProcessRSI error
                    liveTableDataMap.set(item.symbol, item);
                }
            });

            scheduleTableRender(); // Render after each batch

            // Introduce a delay between batches to respect rate limits
            if (i + SYMBOLS_PER_BATCH < allUsdtPairs.length) {
                await new Promise(resolve => setTimeout(resolve, BATCH_PROCESSING_DELAY_MS));
            }
        }
        console.log("Finished refreshing all symbols table data.");
    };


    /**
     * Loads all USDT perpetual symbols from Binance, populates the dropdown,
     * and then initializes the live table tracking.
     */
    const loadSymbolsAndInitializeApp = async () => {
      const symbolSelect = document.getElementById('symbolSelect');
      symbolSelect.innerHTML = `<option disabled selected>Loading symbols...</option>`; // Initial loading state

      const exchangeInfoUrl = `https://fapi.binance.com/fapi/v1/exchangeInfo`;
      try {
        const res = await fetch(exchangeInfoUrl);
        if (!res.ok) {
          throw new Error(`HTTP error! status: ${res.status}`);
        }
        const data = await res.json();

        // Filter for USDT perpetual trading pairs that are currently active
        allUsdtPairs = data.symbols
          .filter(s => s.quoteAsset === 'USDT' && s.contractType === 'PERPETUAL' && s.status === 'TRADING')
          .map(s => s.symbol);

        // Populate the symbol selection dropdown
        symbolSelect.innerHTML = `<option disabled selected>Select a symbol</option>`;
        allUsdtPairs.forEach(sym => {
          const opt = document.createElement('option');
          opt.value = sym;
          opt.textContent = sym;
          symbolSelect.appendChild(opt);
        });

        // Initial refresh of the table data
        await refreshAllSymbolsTableData();

        // Start periodic refresh for the table data
        setInterval(refreshAllSymbolsTableData, UPDATE_INTERVAL_MS);

      } catch (error) {
        console.error('Failed to load symbols or initial data:', error);
        symbolSelect.innerHTML = `<option disabled selected>Error loading symbols</option>`;
        document.getElementById('allSymbolsTableBody').innerHTML = '<tr><td colspan="5" class="text-center text-red-500 py-4">Failed to load symbols for table.</td></tr>';
      }
    };

    // Event listener for when a symbol is selected from the dropdown
    document.getElementById('symbolSelect').onchange = (event) => {
      const selectedSymbol = event.target.value;
      document.getElementById('signal').textContent = 'Loading live data...';
      document.getElementById('currentSymbolInfo').textContent = '';
      fetchInitialKlinesForSingleSymbol(selectedSymbol);
      connectSingleSymbolWebSocket(selectedSymbol);
    };

    // Initial load of symbols and data for the table when the page loads
    loadSymbolsAndInitializeApp();
  </script>
</body>
</html>
